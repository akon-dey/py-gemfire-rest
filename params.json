{"name":"Py-gemfire-rest","tagline":"Python client for Gemfire's REST service.","body":"Python Client for GemFire\r\n=========================\r\n\r\nFor a quick getting started guide please see README for the project at https://github.com/gemfire/py-gemfire-rest\r\n\r\nWith the 8.0 release, GemFire now supports a RESTful API enabling any programming language to be used for writing highly scalable applications. We have also released an open-source implementation of a python package (https://github.com/gemfire/py-gemfire-rest) that utilizes GemFire’s REST API.\r\nWith this package:\r\n* Your application can define the data models entirely in python. (We require that you add “id” instance variable)\r\n* Use Spring’s CrudRepository like interface to store/access your data.\r\n\r\nSay, you want to create a simple social networking application in which you store user profiles and the posts they make. This means your two classes could be defined as:\r\n```python\r\nclass Profile:\r\n    def __init__(self, id, name, friends=None):\r\n        self.id = id\r\n        self.name = name\r\n        self.friends = friends\r\n\r\nclass Posts:\r\n    def __init__(self, id, author, status, timestamp=time.clock()):\r\n        self.id = id\r\n        self.author = author\r\n        self.status = status\r\n        self.timestamp = timestamp\r\n```\r\n\r\n# Starting the GemFire data grid\r\n--------------------------------\r\nPlease [install GemFire for your operating system](http://gemfire.docs.pivotal.io/latest/userguide/index.html#getting_started/install_intro.html). Now, let us start a GemFire cluster to store your data; GemFire cluster is made up of two types of members, “locators” and “servers”. A locator is a service that enables GemFire servers to discover each other, facilitates load balancing etc. From GemFireSHell (gfsh) start a locator as follows: (For high availability, you should start more than one locator per cluster)\r\n```shell\r\ngfsh>start locator --name=locator1\r\n```\r\nA GemFire “server” is a process which manages your data. All nodes talk to one another. A server can be stated as follows\r\n```shell\r\ngfsh>start server --name=server1\r\n```\r\nA server with a REST endpoint can be stated as follows\r\n```shell\r\ngfsh>start server --name=server2 --J=-Dgemfire.start-dev-rest-api=true --J=-Dgemfire.http-service-port=8080\r\n```\r\nLet us create Regions (RDBMS equivalent of Tables) to stores this data\r\n```shell\r\ngfsh>create region --name=profiles --type=REPLICATE\r\n```\r\nA replicate region maintains a copy of the entire data on each server\r\n```shell\r\ngfsh>create region --name=posts --type=PARTITION\r\n```\r\nA partitioned region splits its contents among all servers\r\n\r\n# Writing Python Application\r\n----------------------------\r\nNow that we have the GemFire RESTful service started, we can create our client instance and store data:\r\n```python\r\n#create client using hostname and port of GemFire’s REST service endpoint\r\nclient = GemfireClient(hostname=\"localhost\", port=8080)\r\n```\r\n[All methods on GemfireClient](#gemfireclient-api). From this client we can create repositories for storing our entities\r\n```python\r\n#create a repository for storing profiles\r\nprofiles = client.create_repository(\"profiles\")\r\n\r\n#save profiles in GemFire\r\nuser1 = Profile(1, \"Ethan\")\r\nprofiles.save(user1)\r\n\r\n#you can also pass a list of entities, efficient for bulk loading\r\npost1 = Post(1, \"Ethan\", \"Eating Toast!\")\r\npost2 = Post(2, \"Isabella\", \"Drinking Coffee\")\r\nposts = client.create_repository(\"posts\")\r\nposts.save([post1, post2])\r\n\r\n# find an existing profile\r\nuser = profiles.find(1)\r\n```\r\n[All methods on Repository](#repository-api)\r\n\r\nFor specialized operations like compare_and_set, putIfAbsent etc. you can obtain the Region directly from the repository:\r\n```python\r\nprofile_region = profiles.get_region()\r\n```\r\n[All methods on Region](#region-api)\r\n\r\n# Query\r\n--------\r\nGemFire supports OQL queries. For an example, let us say we want to get all posts by Ethan. We can write an ad-hoc query as follows:\r\n```python\r\nresult = client.adhoc_query(\"select * from /posts where author='Ethan' \")\r\n    for p in result:\r\n        print p.status\r\n```\r\n\r\n## Prepared Query\r\n-----------------\r\nWhen we want to use the above query for a different author, we can create a prepared query by passing an identifier for the prepared query along with the actual query string. We can use the identifier to run a prepared query at a later point. In the below example, we create a prepared query identified by “all_posts” and later use that identifier to run the query by passing in the parameters.\r\n```python\r\n    client.new_query(\"all_posts\", \"select * from /posts where author=$1\")\r\n    result = client.run_query(\"all_posts\", \"Ethan\")\r\n    for p in result:\r\n        print p.status\r\n```\r\n\r\n# Accessing data from Other Languages\r\n-------------------------------------\r\n\r\nGemFire internally saves this data in its Portable Data eXchange format (PDX), so it is possible to access and modify the data inserted from python in other languages. The following code snippet demonstrates how this can be done from GemFire’s Java client:\r\n```java\r\n//create a client-cache to access server data\r\nClientCacheFactory cf = new ClientCacheFactory();\r\ncf.addPoolLocator(\"localhost\", 10334);\r\nClientCache cache = cf.create();\r\n\r\n//create a reference to the region on the client\r\nClientRegionFactory<Integer, Profile> rf = cache.createClientRegionFactory(ClientRegionShortcut.PROXY);\r\nRegion profiles = rf.create(\"profiles\");\r\n\r\n//get the profile for user id 1\r\nPdxInstance user1 = (PdxInstance) profiles.get(\"1\");\r\nSystem.out.println(\"get returned:\"+user1.getField(\"name\")); //prints Ethan\r\n\r\n// modify the profile\r\nWritablePdxInstance userModified = user1.createWriter();\r\nuserModified.setField(\"name\", \"Ethan Jr\");\r\nprofiles.put(\"1\", userModified);\r\n```\r\n\r\n# API\r\n-----\r\nA complete list of methods for GemfireClient, Repository and Region modules:\r\n\r\n## GemfireClient <a name=\"gemfireclient-api\"></a>\r\n----------------\r\n```python\r\n__init__(self, hostname, port, debug_mode=False)\r\n      #Initializes the Client with the given hostname and port\r\n\r\nadhoc_query(self, query_string)\r\n      #Runs an adhoc Query\r\n\r\nconnection(self)\r\n      #Checks connection to the server\r\n\r\ncreate_repository(self, name)\r\n      #Initializes and returns a Repository Object\r\n\r\nerror_response(self, data)\r\n      #Processes HTTP error responses\r\n\r\nexecute_function(self, region_name, func_id, value)\r\n      #Run function\r\n\r\nlist_all_functions(self)\r\n      #List all stored function ID's stored on server\r\n\r\nlist_all_queries(self)\r\n      #Lists all stored Queries in the server\r\n\r\nlist_all_regions(self)\r\n      #Lists all names of Regions present in the server\r\n\r\nnew_query(self, query_id, query_string)\r\n      #Creates a new Query and adds it to the server\r\n\r\nrun_query(self, query_id, query_args)\r\n      #Runs the Query with specified parameters\r\n```\r\n## Repository <a name=\"repository-api\"></a>\r\n-------------\r\n```python\r\n__init__(self, name, base_url, type)\r\n      #Initializes a Repository\r\n\r\ndelete(self, entities)\r\n      #Deletes the specified Object from the region\r\n\r\ndelete_all(self)\r\n      #Deletes all data in the region\r\n\r\nexists(self, id)\r\n      #Checks whether an Object with the given id exists\r\n\r\nfind(self, ids)\r\n      #Retrieves Object(s) by the given ID(s) from the region\r\n\r\nfind_all(self)\r\n      #Returns all data in the region\r\n\r\nget_region(self)\r\n      #Instantiates and returns a Region object\r\n\r\nsave(self, entities)\r\n      #Saves(s) all given Objects in the region\r\n\r\n```\r\n## Region <a name=\"region-api\"></a>\r\n```python\r\n__getitem__(self, key)\r\n      #Method to support region[key] notion\r\n\r\n__init__(self, name, base_url, type)\r\n      #Initializes a Region\r\n\r\nclear(self)\r\n      #Deletes all data in the Region\r\n\r\ncompare_and_set(self, key, oldvalue, newvalue)\r\n      #Compares old values and if identical replaces with a new value\r\n\r\ncreate(self, key, value)\r\n      #Creates a new data value in the Region if the key is absent\r\n\r\ndelete(self, *arg)\r\n      #Deletes the corresponding data value for the specified key\r\n\r\nerror_response(self, data)\r\n      #Processes HTTP error responses\r\n\r\nget(self, *arg)\r\n      #Returns the data value for a specified key\r\n\r\nget_all(self)\r\n      #Returns all the data in a Region\r\n\r\nkeys(self)\r\n      #Returns all keys in the Region\r\n\r\nput(self, key, value)\r\n      #Updates or inserts data for a specified key\r\n\r\nput_all(self, item)\r\n      #Insert or updates data for multiple keys specified by a hashtable\r\n\r\nupdate(self, key, value)\r\n      #Updates the data in a region only if the specified key is present\r\n\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}