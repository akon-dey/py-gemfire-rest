{"name":"Py-gemfire-rest","tagline":"Python client for Gemfire's REST service.","body":"# py-gemfire-rest\r\n=================\r\n\r\nFor a quick getting started guide please see README for the project at https://github.com/gemfire/py-gemfire-rest\r\n\r\nWith the 8.0 release, GemFire now supports a RESTful API enabling any programming language to be used for writing highly scalable applications. We have also released an open-source implementation of a python package (https://github.com/gemfire/py-gemfire-rest) that utilizes GemFire’s REST API.\r\nWith this package:\r\n* Your application can define the data models entirely in python. (We require that you add “id” instance variable)\r\n* Use Spring’s CrudRepository like interface to store/access your data.\r\n\r\nSay, you want to create a simple social networking application in which you store user profiles and the posts they make. This means your two classes could be defined as:\r\n```\r\nclass Profile:\r\n    def __init__(self, id, name, friends=None):\r\n        self.id = id\r\n        self.name = name\r\n        self.friends = friends\r\n\r\nclass Posts:\r\n    def __init__(self, id, author, status, timestamp=time.clock()):\r\n        self.id = id\r\n        self.author = author\r\n        self.status = status\r\n        self.timestamp = timestamp\r\n```\r\n\r\nStarting the GemFire data grid\r\n==============================\r\nPlease [install GemFire for your operating system](http://gemfire.docs.pivotal.io/latest/userguide/index.html#getting_started/install_intro.html). Now, let us start a GemFire cluster to store your data; GemFire cluster is made up of two types of members, “locators” and “servers”. A locator is a service that enables GemFire servers to discover each other, facilitates load balancing etc. From GemFireSHell (gfsh) start a locator as follows: (For high availability, you should start more than one locator per cluster)\r\n```\r\ngfsh>start locator --name=locator1\r\n```\r\nA GemFire “server” is a process which manages your data. All nodes talk to one another. A server can be stated as follows\r\n```\r\ngfsh>start server --name=server1\r\n```\r\nA server with a REST endpoint can be stated as follows\r\n```\r\ngfsh>start server --name=server2 --J=-Dgemfire.start-dev-rest-api=true --J=-Dgemfire.http-service-port=8080\r\n```\r\nLet us create Regions (RDBMS equivalent of Tables) to stores this data\r\n```\r\ngfsh>create region --name=profiles --type=REPLICATE\r\n```\r\nA replicate region maintains a copy of the entire data on each server\r\n```\r\ngfsh>create region --name=posts --type=PARTITION\r\n```\r\nA partitioned region splits its contents among all servers\r\n\r\nWriting Python Application\r\n==========================\r\nNow that we have the GemFire RESTful service started, we can create our client instance and store data:\r\n```\r\n#create client using hostname and port of GemFire’s REST service endpoint\r\nclient = GemfireClient(hostname=\"localhost\", port=8080)\r\n\r\n#create a repository for storing profiles\r\nprofiles = client.create_repository(“profiles”)\r\n\r\n#save profiles in GemFire\r\nuser1 = Profile(1, “Ethan”)\r\nprofiles.save(user1)\r\n\r\n#you can also pass a list of entities, efficient for bulk loading\r\npost1 = Post(1, \"Ethan\", \"Eating Toast!\")\r\npost2 = Post(2, \"Isabella\", \"Drinking Coffee\")\r\nposts = client.create_repository(\"posts\")\r\nposts.save([post1, post2])\r\n\r\n# find an existing profile\r\nuser2 = profiles.find(1)\r\n```\r\n\r\nA complete list of methods for GemfireClient and the Repository modules:\r\n\r\n\r\nFor specialized operations on the Region like compare and set, putIfAbsent etc. you can obtain the Region directly from the repository:\r\nprofile_region = profiles.get_region()\r\nA complete list of Region methods is:\r\n\r\n\r\nQuery\r\n=====\r\nGemFire supports OQL queries. For an example, let us say we want to get all posts by Ethan. We can write an ad-hoc query as follows:\r\n```\r\nresult = client.adhoc_query(\"select * from /posts where author='Ethan' \")\r\n    for p in result:\r\n        print p.status\r\n```\r\nWhen we want to use the above query for a different author, we can create a prepared query by passing an identifier for the prepared query along with the actual query string. We can use the identifier to run a prepared query at a later point. In the below example, we create a prepared query identified by “all_posts” and later use that identifier to run the query by passing in the parameters.\r\n```\r\n    client.new_query(\"all_posts\", \"select * from /posts where author=$1\")\r\n    result = client.run_query(\"all_posts\", \"Ethan\")\r\n    for p in result:\r\n        print p.status\r\n```\r\n\r\nAccessing data from Other Languages\r\n===================================\r\n\r\nGemFire internally saves this data in its Portable Data eXchange format (PDX), so it is possible to access and modify the data inserted from python in other languages. The following code snippet demonstrates how this can be done from GemFire’s Java client:\r\n```\r\nClientCacheFactory cf = new ClientCacheFactory();\r\n\t\tcf.addPoolLocator(“localhost”, 10334);\r\n\t\tClientCache cache = cf.create();\r\n\t\tClientRegionFactory<Integer, Profile> rf = cache.createClientRegionFactory(ClientRegionShortcut.PROXY);\r\n\t\tRegion profiles = rf.create(\"profiles\");\r\n\t\tPdxInstance user1 = (PdxInstance) profiles.get(\"1\");\r\n\t\tSystem.out.println(\"get returned:\"+user1.getField(\"name\")); //prints Ethan\r\n\t\tWritablePdxInstance userModified = user1.createWriter();\r\n\t\tuserModified.setField(\"name\", \"Ethan Jr\");\r\n\t\tprofiles.put(\"1\", userModified);\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}